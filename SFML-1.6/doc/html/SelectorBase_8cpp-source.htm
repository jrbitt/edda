<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
    <head>
        <title>SFML - Simple and Fast Multimedia Library</title>
        <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="tabs.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <div id="logo">
            <img src="./logo.jpg" width="770" height="200" title="SFML home" alt="SFML logo" />
        </div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.htm"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.htm"><span>Namespaces</span></a></li>
      <li><a href="annotated.htm"><span>Classes</span></a></li>
      <li class="current"><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.htm"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>SelectorBase.cpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">// SFML - Simple and Fast Multimedia Library</span>
<a name="l00004"></a>00004 <span class="comment">// Copyright (C) 2007-2009 Laurent Gomila (laurent.gom@gmail.com)</span>
<a name="l00005"></a>00005 <span class="comment">//</span>
<a name="l00006"></a>00006 <span class="comment">// This software is provided 'as-is', without any express or implied warranty.</span>
<a name="l00007"></a>00007 <span class="comment">// In no event will the authors be held liable for any damages arising from the use of this software.</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00009"></a>00009 <span class="comment">// Permission is granted to anyone to use this software for any purpose,</span>
<a name="l00010"></a>00010 <span class="comment">// including commercial applications, and to alter it and redistribute it freely,</span>
<a name="l00011"></a>00011 <span class="comment">// subject to the following restrictions:</span>
<a name="l00012"></a>00012 <span class="comment">//</span>
<a name="l00013"></a>00013 <span class="comment">// 1. The origin of this software must not be misrepresented;</span>
<a name="l00014"></a>00014 <span class="comment">//    you must not claim that you wrote the original software.</span>
<a name="l00015"></a>00015 <span class="comment">//    If you use this software in a product, an acknowledgment</span>
<a name="l00016"></a>00016 <span class="comment">//    in the product documentation would be appreciated but is not required.</span>
<a name="l00017"></a>00017 <span class="comment">//</span>
<a name="l00018"></a>00018 <span class="comment">// 2. Altered source versions must be plainly marked as such,</span>
<a name="l00019"></a>00019 <span class="comment">//    and must not be misrepresented as being the original software.</span>
<a name="l00020"></a>00020 <span class="comment">//</span>
<a name="l00021"></a>00021 <span class="comment">// 3. This notice may not be removed or altered from any source distribution.</span>
<a name="l00022"></a>00022 <span class="comment">//</span>
<a name="l00024"></a>00024 <span class="comment"></span>
<a name="l00025"></a>00025 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span><span class="preprocessor">    #pragma warning(disable : 4127) // "conditional expression is constant" generated by the FD_SET macro</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span>
<a name="l00030"></a>00030 <span class="comment">// Headers</span>
<a name="l00032"></a>00032 <span class="comment"></span><span class="preprocessor">#include &lt;SFML/Network/SelectorBase.hpp&gt;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="keyword">namespace </span>sf
<a name="l00036"></a>00036 {
<a name="l00040"></a><a class="code" href="classsf_1_1SelectorBase.htm#9e09a7275fbbffc8519dc8462a7bbf8d">00040</a> <a class="code" href="classsf_1_1SelectorBase.htm#9e09a7275fbbffc8519dc8462a7bbf8d" title="Default constructor.">SelectorBase::SelectorBase</a>() :
<a name="l00041"></a>00041 myMaxSocket(0)
<a name="l00042"></a>00042 {
<a name="l00043"></a>00043     <a class="code" href="classsf_1_1SelectorBase.htm#e24ec8c1ac981b8411c1c209daf788d0" title="Remove all sockets.">Clear</a>();
<a name="l00044"></a>00044 }
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 
<a name="l00050"></a><a class="code" href="classsf_1_1SelectorBase.htm#42b4a3dc10eec94f7c2631f624ea087f">00050</a> <span class="keywordtype">void</span> <a class="code" href="classsf_1_1SelectorBase.htm#42b4a3dc10eec94f7c2631f624ea087f" title="Add a socket to watch.">SelectorBase::Add</a>(SocketHelper::SocketType Socket)
<a name="l00051"></a>00051 {
<a name="l00052"></a>00052     FD_SET(Socket, &amp;mySet);
<a name="l00053"></a>00053 
<a name="l00054"></a>00054     <span class="keywordtype">int</span> Size = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(Socket);
<a name="l00055"></a>00055     <span class="keywordflow">if</span> (Size &gt; myMaxSocket)
<a name="l00056"></a>00056         myMaxSocket = Size;
<a name="l00057"></a>00057 }
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 
<a name="l00063"></a><a class="code" href="classsf_1_1SelectorBase.htm#319664dddf8c2170ef5b6908c39de80e">00063</a> <span class="keywordtype">void</span> <a class="code" href="classsf_1_1SelectorBase.htm#319664dddf8c2170ef5b6908c39de80e" title="Remove a socket.">SelectorBase::Remove</a>(SocketHelper::SocketType Socket)
<a name="l00064"></a>00064 {
<a name="l00065"></a>00065     FD_CLR(Socket, &amp;mySet);
<a name="l00066"></a>00066 }
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 
<a name="l00072"></a><a class="code" href="classsf_1_1SelectorBase.htm#e24ec8c1ac981b8411c1c209daf788d0">00072</a> <span class="keywordtype">void</span> <a class="code" href="classsf_1_1SelectorBase.htm#e24ec8c1ac981b8411c1c209daf788d0" title="Remove all sockets.">SelectorBase::Clear</a>()
<a name="l00073"></a>00073 {
<a name="l00074"></a>00074     FD_ZERO(&amp;mySet);
<a name="l00075"></a>00075     FD_ZERO(&amp;mySetReady);
<a name="l00076"></a>00076 
<a name="l00077"></a>00077     myMaxSocket = 0;
<a name="l00078"></a>00078 }
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 
<a name="l00086"></a><a class="code" href="classsf_1_1SelectorBase.htm#22ba5625f8b644effa55e1a1c43efa4f">00086</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classsf_1_1SelectorBase.htm#22ba5625f8b644effa55e1a1c43efa4f" title="Wait and collect sockets which are ready for reading.">SelectorBase::Wait</a>(<span class="keywordtype">float</span> Timeout)
<a name="l00087"></a>00087 {
<a name="l00088"></a>00088     <span class="comment">// Setup the timeout structure</span>
<a name="l00089"></a>00089     timeval Time;
<a name="l00090"></a>00090     Time.tv_sec  = <span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span><span class="keyword">&gt;</span>(Timeout);
<a name="l00091"></a>00091     Time.tv_usec = (<span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span><span class="keyword">&gt;</span>(Timeout * 1000) % 1000) * 1000;
<a name="l00092"></a>00092 
<a name="l00093"></a>00093     <span class="comment">// Prepare the set of sockets to return</span>
<a name="l00094"></a>00094     mySetReady = mySet;
<a name="l00095"></a>00095 
<a name="l00096"></a>00096     <span class="comment">// Wait until one of the sockets is ready for reading, or timeout is reached</span>
<a name="l00097"></a>00097     <span class="keywordtype">int</span> NbSockets = select(myMaxSocket + 1, &amp;mySetReady, NULL, NULL, Timeout &gt; 0 ? &amp;Time : NULL);
<a name="l00098"></a>00098 
<a name="l00099"></a>00099     <span class="keywordflow">return</span> NbSockets &gt;= 0 ? <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(NbSockets) : 0;
<a name="l00100"></a>00100 }
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 
<a name="l00108"></a><a class="code" href="classsf_1_1SelectorBase.htm#36e6a8d623f97a3c91701113931a0389">00108</a> SocketHelper::SocketType <a class="code" href="classsf_1_1SelectorBase.htm#36e6a8d623f97a3c91701113931a0389" title="After a call to Wait(), get the Index-th socket which is ready for reading.">SelectorBase::GetSocketReady</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Index)
<a name="l00109"></a>00109 {
<a name="l00110"></a>00110     <span class="comment">// The standard FD_xxx interface doesn't define a direct access,</span>
<a name="l00111"></a>00111     <span class="comment">// so we must go through the whole set to find the socket we're looking for</span>
<a name="l00112"></a>00112     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; myMaxSocket + 1; ++i)
<a name="l00113"></a>00113     {
<a name="l00114"></a>00114         <span class="keywordflow">if</span> (FD_ISSET(i, &amp;mySetReady))
<a name="l00115"></a>00115         {
<a name="l00116"></a>00116             <span class="comment">// Current socket is ready, but is it the Index-th one ?</span>
<a name="l00117"></a>00117             <span class="keywordflow">if</span> (Index &gt; 0)
<a name="l00118"></a>00118             {
<a name="l00119"></a>00119                 Index--;
<a name="l00120"></a>00120             }
<a name="l00121"></a>00121             <span class="keywordflow">else</span>
<a name="l00122"></a>00122             {
<a name="l00123"></a>00123                 <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>SocketHelper::SocketType<span class="keyword">&gt;</span>(i);
<a name="l00124"></a>00124             }
<a name="l00125"></a>00125         }
<a name="l00126"></a>00126     }
<a name="l00127"></a>00127 
<a name="l00128"></a>00128     <span class="comment">// Invalid index : return an invalid socket</span>
<a name="l00129"></a>00129     <span class="keywordflow">return</span> <a class="code" href="classsf_1_1SocketHelper.htm#99e426a217cc8847264f837632b4e458" title="Return the value of the invalid socket.">SocketHelper::InvalidSocket</a>();
<a name="l00130"></a>00130 }
<a name="l00131"></a>00131 
<a name="l00132"></a>00132 } <span class="comment">// namespace sf</span>
</pre></div></div>

        <p id="footer">
            &nbsp;::&nbsp; Copyright &copy; 2007-2008 Laurent Gomila, all rights reserved &nbsp;::&nbsp;
            Documentation generated by <a href="http://www.doxygen.org/" title="doxygen website">doxygen 1.5.2</a> &nbsp;::&nbsp;
        </p>

    </body>
</html>
