<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
    <head>
        <title>SFML - Simple and Fast Multimedia Library</title>
        <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="tabs.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <div id="logo">
            <img src="./logo.jpg" width="770" height="200" title="SFML home" alt="SFML logo" />
        </div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.htm"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.htm"><span>Namespaces</span></a></li>
      <li><a href="annotated.htm"><span>Classes</span></a></li>
      <li class="current"><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.htm"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>Unicode.cpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">// SFML - Simple and Fast Multimedia Library</span>
<a name="l00004"></a>00004 <span class="comment">// Copyright (C) 2007-2009 Laurent Gomila (laurent.gom@gmail.com)</span>
<a name="l00005"></a>00005 <span class="comment">//</span>
<a name="l00006"></a>00006 <span class="comment">// This software is provided 'as-is', without any express or implied warranty.</span>
<a name="l00007"></a>00007 <span class="comment">// In no event will the authors be held liable for any damages arising from the use of this software.</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00009"></a>00009 <span class="comment">// Permission is granted to anyone to use this software for any purpose,</span>
<a name="l00010"></a>00010 <span class="comment">// including commercial applications, and to alter it and redistribute it freely,</span>
<a name="l00011"></a>00011 <span class="comment">// subject to the following restrictions:</span>
<a name="l00012"></a>00012 <span class="comment">//</span>
<a name="l00013"></a>00013 <span class="comment">// 1. The origin of this software must not be misrepresented;</span>
<a name="l00014"></a>00014 <span class="comment">//    you must not claim that you wrote the original software.</span>
<a name="l00015"></a>00015 <span class="comment">//    If you use this software in a product, an acknowledgment</span>
<a name="l00016"></a>00016 <span class="comment">//    in the product documentation would be appreciated but is not required.</span>
<a name="l00017"></a>00017 <span class="comment">//</span>
<a name="l00018"></a>00018 <span class="comment">// 2. Altered source versions must be plainly marked as such,</span>
<a name="l00019"></a>00019 <span class="comment">//    and must not be misrepresented as being the original software.</span>
<a name="l00020"></a>00020 <span class="comment">//</span>
<a name="l00021"></a>00021 <span class="comment">// 3. This notice may not be removed or altered from any source distribution.</span>
<a name="l00022"></a>00022 <span class="comment">//</span>
<a name="l00024"></a>00024 <span class="comment"></span>
<a name="l00026"></a>00026 <span class="comment">// Headers</span>
<a name="l00028"></a>00028 <span class="comment"></span><span class="preprocessor">#include &lt;SFML/System/Unicode.hpp&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 
<a name="l00034"></a>00034 <span class="comment">// References :</span>
<a name="l00035"></a>00035 <span class="comment">//</span>
<a name="l00036"></a>00036 <span class="comment">// http://www.unicode.org/</span>
<a name="l00037"></a>00037 <span class="comment">// http://www.unicode.org/Public/PROGRAMS/CVTUTF/ConvertUTF.c</span>
<a name="l00038"></a>00038 <span class="comment">// http://www.unicode.org/Public/PROGRAMS/CVTUTF/ConvertUTF.h</span>
<a name="l00039"></a>00039 <span class="comment">// http://people.w3.org/rishida/scripts/uniview/conversion</span>
<a name="l00040"></a>00040 <span class="comment">//</span>
<a name="l00042"></a>00042 <span class="comment"></span>
<a name="l00043"></a>00043 <span class="keyword">namespace</span>
<a name="l00044"></a>00044 {
<a name="l00046"></a>00046     <span class="comment">// Generic utility function to compute the number</span>
<a name="l00047"></a>00047     <span class="comment">// of characters in a null-terminated string of any type</span>
<a name="l00049"></a>00049 <span class="comment"></span>    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00050"></a>00050     std::size_t StrLen(<span class="keyword">const</span> T* Str)
<a name="l00051"></a>00051     {
<a name="l00052"></a>00052         std::size_t Length = 0;
<a name="l00053"></a>00053         <span class="keywordflow">while</span> (*Str++) Length++;
<a name="l00054"></a>00054         <span class="keywordflow">return</span> Length;
<a name="l00055"></a>00055     }
<a name="l00056"></a>00056 
<a name="l00058"></a>00058     <span class="comment">// Get the current system locale</span>
<a name="l00060"></a>00060 <span class="comment"></span>    std::locale GetCurrentLocale()
<a name="l00061"></a>00061     {
<a name="l00062"></a>00062         <span class="keywordflow">try</span>
<a name="l00063"></a>00063         {
<a name="l00064"></a>00064             <span class="keywordflow">return</span> std::locale(<span class="stringliteral">""</span>);
<a name="l00065"></a>00065         }
<a name="l00066"></a>00066         <span class="keywordflow">catch</span> (std::runtime_error&amp;)
<a name="l00067"></a>00067         {
<a name="l00068"></a>00068             <span class="comment">// It seems some implementations don't know the "" locale</span>
<a name="l00069"></a>00069             <span class="comment">// (Mac OS, MinGW)</span>
<a name="l00070"></a>00070 
<a name="l00071"></a>00071             <span class="keywordflow">return</span> std::locale();
<a name="l00072"></a>00072         }
<a name="l00073"></a>00073     }
<a name="l00074"></a>00074 }
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 <span class="keyword">namespace </span>sf
<a name="l00077"></a>00077 {
<a name="l00079"></a>00079 <span class="comment">// Static member data</span>
<a name="l00081"></a>00081 <span class="comment"></span><span class="keyword">const</span> <span class="keywordtype">int</span> Unicode::UTF8TrailingBytes[256] =
<a name="l00082"></a>00082 {
<a name="l00083"></a>00083     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
<a name="l00084"></a>00084     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
<a name="l00085"></a>00085     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
<a name="l00086"></a>00086     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
<a name="l00087"></a>00087     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
<a name="l00088"></a>00088     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
<a name="l00089"></a>00089     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
<a name="l00090"></a>00090     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5
<a name="l00091"></a>00091 };
<a name="l00092"></a>00092 <span class="keyword">const</span> Uint32 Unicode::UTF8Offsets[6] =
<a name="l00093"></a>00093 {
<a name="l00094"></a>00094     0x00000000, 0x00003080, 0x000E2080, 0x03C82080, 0xFA082080, 0x82082080
<a name="l00095"></a>00095 };
<a name="l00096"></a>00096 <span class="keyword">const</span> Uint8 Unicode::UTF8FirstBytes[7] =
<a name="l00097"></a>00097 {
<a name="l00098"></a>00098     0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC
<a name="l00099"></a>00099 };
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 
<a name="l00105"></a><a class="code" href="classsf_1_1Unicode_1_1Text.htm#aa04a48e0feb1243b06b32e00e1b572d">00105</a> <a class="code" href="classsf_1_1Unicode_1_1Text.htm#aa04a48e0feb1243b06b32e00e1b572d" title="Default constructor (empty text).">Unicode::Text::Text</a>()
<a name="l00106"></a>00106 {
<a name="l00107"></a>00107     <span class="comment">// Nothing to do</span>
<a name="l00108"></a>00108 }
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 
<a name="l00114"></a><a class="code" href="classsf_1_1Unicode_1_1Text.htm#ce4c2b97e31442ab88ea8eabf75ff4e6">00114</a> <a class="code" href="classsf_1_1Unicode_1_1Text.htm#aa04a48e0feb1243b06b32e00e1b572d" title="Default constructor (empty text).">Unicode::Text::Text</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* Str)
<a name="l00115"></a>00115 {
<a name="l00116"></a>00116     <span class="keywordflow">if</span> (Str)
<a name="l00117"></a>00117     {
<a name="l00118"></a>00118         std::size_t Length = StrLen(Str);
<a name="l00119"></a>00119         <span class="keywordflow">if</span> (Length &gt; 0)
<a name="l00120"></a>00120         {
<a name="l00121"></a>00121             myUTF32String.reserve(Length + 1);
<a name="l00122"></a>00122             <a class="code" href="classsf_1_1Unicode.htm#164436a4e19c18cc518e9d8d921481f1" title="Generic function to convert an ANSI characters range to an UTF-32 characters range...">Unicode::ANSIToUTF32</a>(Str, Str + Length, std::back_inserter(myUTF32String));
<a name="l00123"></a>00123         }
<a name="l00124"></a>00124     }
<a name="l00125"></a>00125 }
<a name="l00126"></a>00126 <a class="code" href="classsf_1_1Unicode_1_1Text.htm#aa04a48e0feb1243b06b32e00e1b572d" title="Default constructor (empty text).">Unicode::Text::Text</a>(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* Str)
<a name="l00127"></a>00127 {
<a name="l00128"></a>00128     <span class="keywordflow">if</span> (Str)
<a name="l00129"></a>00129     {
<a name="l00130"></a>00130         std::size_t Length = StrLen(Str);
<a name="l00131"></a>00131         <span class="keywordflow">if</span> (Length &gt; 0)
<a name="l00132"></a>00132         {
<a name="l00133"></a>00133             <span class="comment">// See comments below, in Unicode::Text::Text(const std::wstring&amp;)</span>
<a name="l00134"></a>00134             myUTF32String.reserve(Length + 1);
<a name="l00135"></a>00135             <span class="keywordflow">switch</span> (<span class="keyword">sizeof</span>(<span class="keywordtype">wchar_t</span>))
<a name="l00136"></a>00136             {
<a name="l00137"></a>00137                 <span class="keywordflow">case</span> 2 : <a class="code" href="classsf_1_1Unicode.htm#5e9edaac35984964ef3ad353f98f9f73" title="Generic function to convert an UTF-16 characters range to an UTF-32 characters range...">Unicode::UTF16ToUTF32</a>(Str, Str + Length, std::back_inserter(myUTF32String), 0); <span class="keywordflow">break</span>;
<a name="l00138"></a>00138                 <span class="keywordflow">case</span> 4 : std::copy(Str, Str + Length, std::back_inserter(myUTF32String));                <span class="keywordflow">break</span>;
<a name="l00139"></a>00139                 <span class="keywordflow">default</span> : <span class="keywordflow">break</span>;
<a name="l00140"></a>00140             }
<a name="l00141"></a>00141         }
<a name="l00142"></a>00142     }
<a name="l00143"></a>00143 }
<a name="l00144"></a>00144 <a class="code" href="classsf_1_1Unicode_1_1Text.htm#aa04a48e0feb1243b06b32e00e1b572d" title="Default constructor (empty text).">Unicode::Text::Text</a>(<span class="keyword">const</span> Uint8* Str)
<a name="l00145"></a>00145 {
<a name="l00146"></a>00146     <span class="keywordflow">if</span> (Str)
<a name="l00147"></a>00147     {
<a name="l00148"></a>00148         std::size_t Length = StrLen(Str);
<a name="l00149"></a>00149         <span class="keywordflow">if</span> (Length &gt; 0)
<a name="l00150"></a>00150         {
<a name="l00151"></a>00151             myUTF32String.reserve(Length + 1);
<a name="l00152"></a>00152             <a class="code" href="classsf_1_1Unicode.htm#c4a67f01b57053b697c573b0ab6a9545" title="Generic function to convert an UTF-8 characters range to an UTF-32 characters range...">Unicode::UTF8ToUTF32</a>(Str, Str + Length, std::back_inserter(myUTF32String), 0);
<a name="l00153"></a>00153         }
<a name="l00154"></a>00154     }
<a name="l00155"></a>00155 }
<a name="l00156"></a>00156 <a class="code" href="classsf_1_1Unicode_1_1Text.htm#aa04a48e0feb1243b06b32e00e1b572d" title="Default constructor (empty text).">Unicode::Text::Text</a>(<span class="keyword">const</span> Uint16* Str)
<a name="l00157"></a>00157 {
<a name="l00158"></a>00158     <span class="keywordflow">if</span> (Str)
<a name="l00159"></a>00159     {
<a name="l00160"></a>00160         std::size_t Length = StrLen(Str);
<a name="l00161"></a>00161         <span class="keywordflow">if</span> (Length &gt; 0)
<a name="l00162"></a>00162         {
<a name="l00163"></a>00163             myUTF32String.reserve(Length+ 1);
<a name="l00164"></a>00164             <a class="code" href="classsf_1_1Unicode.htm#5e9edaac35984964ef3ad353f98f9f73" title="Generic function to convert an UTF-16 characters range to an UTF-32 characters range...">Unicode::UTF16ToUTF32</a>(Str, Str + Length, std::back_inserter(myUTF32String), 0);
<a name="l00165"></a>00165         }
<a name="l00166"></a>00166     }
<a name="l00167"></a>00167 }
<a name="l00168"></a>00168 <a class="code" href="classsf_1_1Unicode_1_1Text.htm#aa04a48e0feb1243b06b32e00e1b572d" title="Default constructor (empty text).">Unicode::Text::Text</a>(<span class="keyword">const</span> Uint32* Str)
<a name="l00169"></a>00169 {
<a name="l00170"></a>00170     <span class="keywordflow">if</span> (Str)
<a name="l00171"></a>00171         myUTF32String = Str;
<a name="l00172"></a>00172 }
<a name="l00173"></a>00173 <a class="code" href="classsf_1_1Unicode_1_1Text.htm#aa04a48e0feb1243b06b32e00e1b572d" title="Default constructor (empty text).">Unicode::Text::Text</a>(<span class="keyword">const</span> std::string&amp; Str)
<a name="l00174"></a>00174 {
<a name="l00175"></a>00175     myUTF32String.reserve(Str.length() + 1);
<a name="l00176"></a>00176     <a class="code" href="classsf_1_1Unicode.htm#164436a4e19c18cc518e9d8d921481f1" title="Generic function to convert an ANSI characters range to an UTF-32 characters range...">Unicode::ANSIToUTF32</a>(Str.begin(), Str.end(), std::back_inserter(myUTF32String));
<a name="l00177"></a>00177 }
<a name="l00178"></a>00178 <a class="code" href="classsf_1_1Unicode_1_1Text.htm#aa04a48e0feb1243b06b32e00e1b572d" title="Default constructor (empty text).">Unicode::Text::Text</a>(<span class="keyword">const</span> std::wstring&amp; Str)
<a name="l00179"></a>00179 {
<a name="l00180"></a>00180     <span class="comment">// This function assumes that 2-byte large wchar_t are encoded in UTF-16 (Windows), and</span>
<a name="l00181"></a>00181     <span class="comment">// 4-byte large wchar_t are encoded using UTF-32 (Unix)</span>
<a name="l00182"></a>00182     <span class="comment">// Is that always true ? (some platforms may use JIS Japanese encoding)</span>
<a name="l00183"></a>00183     <span class="comment">// The macro __STDC_ISO_10646__ should help identifying UTF-32 compliant implementations</span>
<a name="l00184"></a>00184 
<a name="l00185"></a>00185     myUTF32String.reserve(Str.length() + 1);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187     <span class="comment">// Select the proper function according to the (supposed) wchar_t system encoding</span>
<a name="l00188"></a>00188     <span class="keywordflow">switch</span> (<span class="keyword">sizeof</span>(<span class="keywordtype">wchar_t</span>))
<a name="l00189"></a>00189     {
<a name="l00190"></a>00190         <span class="comment">// wchar_t uses UTF-16 -- need a conversion</span>
<a name="l00191"></a>00191         <span class="keywordflow">case</span> 2 :
<a name="l00192"></a>00192         {
<a name="l00193"></a>00193             <a class="code" href="classsf_1_1Unicode.htm#5e9edaac35984964ef3ad353f98f9f73" title="Generic function to convert an UTF-16 characters range to an UTF-32 characters range...">Unicode::UTF16ToUTF32</a>(Str.begin(), Str.end(), std::back_inserter(myUTF32String), 0);
<a name="l00194"></a>00194             <span class="keywordflow">break</span>;
<a name="l00195"></a>00195         }
<a name="l00196"></a>00196 
<a name="l00197"></a>00197         <span class="comment">// wchar_t uses UTF-32 -- direct copy</span>
<a name="l00198"></a>00198         <span class="keywordflow">case</span> 4 :
<a name="l00199"></a>00199         {
<a name="l00200"></a>00200             std::copy(Str.begin(), Str.end(), std::back_inserter(myUTF32String));
<a name="l00201"></a>00201             <span class="keywordflow">break</span>;
<a name="l00202"></a>00202         }
<a name="l00203"></a>00203 
<a name="l00204"></a>00204         <span class="comment">// This should never happen</span>
<a name="l00205"></a>00205         <span class="keywordflow">default</span> : <span class="keywordflow">break</span>;
<a name="l00206"></a>00206     }
<a name="l00207"></a>00207 }
<a name="l00208"></a>00208 <a class="code" href="classsf_1_1Unicode_1_1Text.htm#aa04a48e0feb1243b06b32e00e1b572d" title="Default constructor (empty text).">Unicode::Text::Text</a>(<span class="keyword">const</span> <a class="code" href="classsf_1_1Unicode.htm#3c6081f88e93693ff8e713053982a9f9" title="Define a string type for each encoding Warning : in UTF8 and UTF16 strings, one element...">Unicode::UTF8String</a>&amp; Str)
<a name="l00209"></a>00209 {
<a name="l00210"></a>00210     myUTF32String.reserve(Str.length() + 1);
<a name="l00211"></a>00211     <a class="code" href="classsf_1_1Unicode.htm#c4a67f01b57053b697c573b0ab6a9545" title="Generic function to convert an UTF-8 characters range to an UTF-32 characters range...">Unicode::UTF8ToUTF32</a>(Str.begin(), Str.end(), std::back_inserter(myUTF32String), 0);
<a name="l00212"></a>00212 }
<a name="l00213"></a>00213 <a class="code" href="classsf_1_1Unicode_1_1Text.htm#aa04a48e0feb1243b06b32e00e1b572d" title="Default constructor (empty text).">Unicode::Text::Text</a>(<span class="keyword">const</span> Unicode::UTF16String&amp; Str)
<a name="l00214"></a>00214 {
<a name="l00215"></a>00215     myUTF32String.reserve(Str.length() + 1);
<a name="l00216"></a>00216     <a class="code" href="classsf_1_1Unicode.htm#5e9edaac35984964ef3ad353f98f9f73" title="Generic function to convert an UTF-16 characters range to an UTF-32 characters range...">Unicode::UTF16ToUTF32</a>(Str.begin(), Str.end(), std::back_inserter(myUTF32String), 0);
<a name="l00217"></a>00217 }
<a name="l00218"></a>00218 <a class="code" href="classsf_1_1Unicode_1_1Text.htm#aa04a48e0feb1243b06b32e00e1b572d" title="Default constructor (empty text).">Unicode::Text::Text</a>(<span class="keyword">const</span> Unicode::UTF32String&amp; Str)
<a name="l00219"></a>00219 {
<a name="l00220"></a>00220     myUTF32String = Str;
<a name="l00221"></a>00221 }
<a name="l00222"></a>00222 
<a name="l00223"></a>00223 
<a name="l00227"></a><a class="code" href="classsf_1_1Unicode_1_1Text.htm#8dafdb0f8af7aa8fd93a6357d14e7dfb">00227</a> Unicode::Text::operator std::string()<span class="keyword"> const</span>
<a name="l00228"></a>00228 <span class="keyword"></span>{
<a name="l00229"></a>00229     std::string Output;
<a name="l00230"></a>00230     Output.reserve(myUTF32String.length() + 1);
<a name="l00231"></a>00231     <a class="code" href="classsf_1_1Unicode.htm#f6acf0453625fe05fc7a86f4cc9a5cf1" title="Generic function to convert an UTF-32 characters range to an ANSI characters range...">Unicode::UTF32ToANSI</a>(myUTF32String.begin(), myUTF32String.end(), std::back_inserter(Output), 0, Unicode::GetDefaultLocale());
<a name="l00232"></a>00232     <span class="keywordflow">return</span> Output;
<a name="l00233"></a>00233 }
<a name="l00234"></a>00234 Unicode::Text::operator std::wstring()<span class="keyword"> const</span>
<a name="l00235"></a>00235 <span class="keyword"></span>{
<a name="l00236"></a>00236     <span class="comment">// This function assumes that 2-byte large wchar_t are encoded in UTF-16 (Windows), and</span>
<a name="l00237"></a>00237     <span class="comment">// 4-byte large wchar_t are encoded using UTF-32 (Unix)</span>
<a name="l00238"></a>00238     <span class="comment">// Is that always true ? (some platforms may use JIS Japanese encoding)</span>
<a name="l00239"></a>00239     <span class="comment">// The macro __STDC_ISO_10646__ should help identifying UTF-32 compliant implementations</span>
<a name="l00240"></a>00240 
<a name="l00241"></a>00241     std::wstring Output;
<a name="l00242"></a>00242     Output.reserve(myUTF32String.length() + 1);
<a name="l00243"></a>00243 
<a name="l00244"></a>00244     <span class="comment">// Select the proper function according to the (supposed) wchar_t system encoding</span>
<a name="l00245"></a>00245     <span class="keywordflow">switch</span> (<span class="keyword">sizeof</span>(<span class="keywordtype">wchar_t</span>))
<a name="l00246"></a>00246     {
<a name="l00247"></a>00247         <span class="comment">// wchar_t uses UTF-16 -- need a conversion</span>
<a name="l00248"></a>00248         <span class="keywordflow">case</span> 2 :
<a name="l00249"></a>00249         {
<a name="l00250"></a>00250             <a class="code" href="classsf_1_1Unicode.htm#b4b5c6e82a1ab1d9ed775653f082d58b" title="Generic function to convert an UTF-32 characters range to an UTF-16 characters range...">UTF32ToUTF16</a>(myUTF32String.begin(), myUTF32String.end(), std::back_inserter(Output), 0);
<a name="l00251"></a>00251             <span class="keywordflow">break</span>;
<a name="l00252"></a>00252         }
<a name="l00253"></a>00253 
<a name="l00254"></a>00254         <span class="comment">// wchar_t uses UTF-32 -- direct copy</span>
<a name="l00255"></a>00255         <span class="keywordflow">case</span> 4 :
<a name="l00256"></a>00256         {
<a name="l00257"></a>00257             std::copy(myUTF32String.begin(), myUTF32String.end(), std::back_inserter(Output));
<a name="l00258"></a>00258             <span class="keywordflow">break</span>;
<a name="l00259"></a>00259         }
<a name="l00260"></a>00260 
<a name="l00261"></a>00261         <span class="comment">// This should never happen</span>
<a name="l00262"></a>00262         <span class="keywordflow">default</span> : <span class="keywordflow">break</span>;
<a name="l00263"></a>00263     }
<a name="l00264"></a>00264     <span class="keywordflow">return</span> Output;
<a name="l00265"></a>00265 }
<a name="l00266"></a>00266 <a class="code" href="classsf_1_1Unicode.htm#3c6081f88e93693ff8e713053982a9f9" title="Define a string type for each encoding Warning : in UTF8 and UTF16 strings, one element...">Unicode::Text::operator sf::Unicode::UTF8String</a>()<span class="keyword"> const</span>
<a name="l00267"></a>00267 <span class="keyword"></span>{
<a name="l00268"></a>00268     <a class="code" href="classsf_1_1Unicode.htm#3c6081f88e93693ff8e713053982a9f9" title="Define a string type for each encoding Warning : in UTF8 and UTF16 strings, one element...">Unicode::UTF8String</a> Output;
<a name="l00269"></a>00269     Output.reserve(myUTF32String.length() * 4 + 1);
<a name="l00270"></a>00270     <a class="code" href="classsf_1_1Unicode.htm#46bba10d3a323183c29b4cb288d053c1" title="Generic function to convert an UTF-32 characters range to an UTF-8 characters range...">Unicode::UTF32ToUTF8</a>(myUTF32String.begin(), myUTF32String.end(), std::back_inserter(Output), 0);
<a name="l00271"></a>00271     <span class="keywordflow">return</span> Output;
<a name="l00272"></a>00272 }
<a name="l00273"></a>00273 Unicode::Text::operator sf::Unicode::UTF16String()<span class="keyword"> const</span>
<a name="l00274"></a>00274 <span class="keyword"></span>{
<a name="l00275"></a>00275     Unicode::UTF16String Output;
<a name="l00276"></a>00276     Output.reserve(myUTF32String.length() * 2 + 1);
<a name="l00277"></a>00277     <a class="code" href="classsf_1_1Unicode.htm#b4b5c6e82a1ab1d9ed775653f082d58b" title="Generic function to convert an UTF-32 characters range to an UTF-16 characters range...">Unicode::UTF32ToUTF16</a>(myUTF32String.begin(), myUTF32String.end(), std::back_inserter(Output), 0);
<a name="l00278"></a>00278     <span class="keywordflow">return</span> Output;
<a name="l00279"></a>00279 }
<a name="l00280"></a>00280 Unicode::Text::operator const sf::Unicode::UTF32String&amp;()<span class="keyword"> const</span>
<a name="l00281"></a>00281 <span class="keyword"></span>{
<a name="l00282"></a>00282     <span class="keywordflow">return</span> myUTF32String;
<a name="l00283"></a>00283 }
<a name="l00284"></a>00284 
<a name="l00285"></a>00285 
<a name="l00289"></a>00289 <span class="keyword">const</span> std::locale&amp; Unicode::GetDefaultLocale()
<a name="l00290"></a>00290 {
<a name="l00291"></a>00291     <span class="comment">// It seems getting the default locale is a very expensive operation,</span>
<a name="l00292"></a>00292     <span class="comment">// so we only do it once and then store the locale for reuse.</span>
<a name="l00293"></a>00293     <span class="comment">// Warning : this code won't be aware of any change of the default locale during runtime</span>
<a name="l00294"></a>00294 
<a name="l00295"></a>00295     <span class="keyword">static</span> std::locale DefaultLocale = GetCurrentLocale();
<a name="l00296"></a>00296 
<a name="l00297"></a>00297     <span class="keywordflow">return</span> DefaultLocale;
<a name="l00298"></a>00298 }
<a name="l00299"></a>00299 
<a name="l00300"></a>00300 } <span class="comment">// namespace sf</span>
</pre></div></div>

        <p id="footer">
            &nbsp;::&nbsp; Copyright &copy; 2007-2008 Laurent Gomila, all rights reserved &nbsp;::&nbsp;
            Documentation generated by <a href="http://www.doxygen.org/" title="doxygen website">doxygen 1.5.2</a> &nbsp;::&nbsp;
        </p>

    </body>
</html>
